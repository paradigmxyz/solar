//! EVM bytecode generation.
//!
//! This module generates EVM bytecode from MIR functions, including:
//! - Function dispatcher with selector matching
//! - Payable checks for non-payable functions
//! - receive() and fallback() handling

use crate::MirFunction;
use solar_ast::StateMutability;
use solar_sema::hir::FunctionKind;

/// EVM opcodes used in codegen.
#[allow(dead_code)]
mod op {
    pub(super) const STOP: u8 = 0x00;
    pub(super) const ADD: u8 = 0x01;
    pub(super) const MUL: u8 = 0x02;
    pub(super) const SUB: u8 = 0x03;
    pub(super) const DIV: u8 = 0x04;
    pub(super) const LT: u8 = 0x10;
    pub(super) const GT: u8 = 0x11;
    pub(super) const EQ: u8 = 0x14;
    pub(super) const ISZERO: u8 = 0x15;
    pub(super) const CALLDATALOAD: u8 = 0x35;
    pub(super) const CALLDATASIZE: u8 = 0x36;
    pub(super) const CALLVALUE: u8 = 0x34;
    pub(super) const PUSH0: u8 = 0x5f;
    pub(super) const PUSH1: u8 = 0x60;
    pub(super) const PUSH2: u8 = 0x61;
    pub(super) const PUSH4: u8 = 0x63;
    pub(super) const PUSH32: u8 = 0x7f;
    pub(super) const DUP1: u8 = 0x80;
    pub(super) const SWAP1: u8 = 0x90;
    pub(super) const JUMP: u8 = 0x56;
    pub(super) const JUMPI: u8 = 0x57;
    pub(super) const JUMPDEST: u8 = 0x5b;
    pub(super) const RETURN: u8 = 0xf3;
    pub(super) const REVERT: u8 = 0xfd;
    pub(super) const INVALID: u8 = 0xfe;
    pub(super) const SELFBALANCE: u8 = 0x47;
    pub(super) const SLOAD: u8 = 0x54;
    pub(super) const SSTORE: u8 = 0x55;
    pub(super) const MSTORE: u8 = 0x52;
    pub(super) const MLOAD: u8 = 0x51;
    pub(super) const SHR: u8 = 0x1c;
}

/// Generated bytecode.
#[derive(Debug, Clone, Default)]
pub struct Bytecode {
    bytes: Vec<u8>,
    labels: Vec<(String, usize)>,
    pending_jumps: Vec<(usize, String)>,
}

impl Bytecode {
    /// Creates a new empty bytecode buffer.
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns the bytecode as bytes.
    pub fn as_bytes(&self) -> &[u8] {
        &self.bytes
    }

    /// Returns the bytecode length.
    pub fn len(&self) -> usize {
        self.bytes.len()
    }

    /// Returns true if the bytecode is empty.
    pub fn is_empty(&self) -> bool {
        self.bytes.is_empty()
    }

    fn emit(&mut self, opcode: u8) {
        self.bytes.push(opcode);
    }

    fn emit_bytes(&mut self, bytes: &[u8]) {
        self.bytes.extend_from_slice(bytes);
    }

    fn emit_push1(&mut self, value: u8) {
        self.emit(op::PUSH1);
        self.emit(value);
    }

    fn emit_push4(&mut self, value: [u8; 4]) {
        self.emit(op::PUSH4);
        self.emit_bytes(&value);
    }

    fn define_label(&mut self, name: &str) {
        self.labels.push((name.to_string(), self.bytes.len()));
        self.emit(op::JUMPDEST);
    }

    fn emit_jump_to(&mut self, label: &str) {
        self.emit(op::PUSH2);
        self.pending_jumps.push((self.bytes.len(), label.to_string()));
        self.emit_bytes(&[0x00, 0x00]);
        self.emit(op::JUMP);
    }

    fn emit_jumpi_to(&mut self, label: &str) {
        self.emit(op::PUSH2);
        self.pending_jumps.push((self.bytes.len(), label.to_string()));
        self.emit_bytes(&[0x00, 0x00]);
        self.emit(op::JUMPI);
    }

    fn resolve_labels(&mut self) {
        for (offset, label) in &self.pending_jumps {
            if let Some((_, addr)) = self.labels.iter().find(|(n, _)| n == label) {
                let addr_bytes = (*addr as u16).to_be_bytes();
                self.bytes[*offset] = addr_bytes[0];
                self.bytes[*offset + 1] = addr_bytes[1];
            }
        }
    }
}

/// EVM code generator.
#[derive(Debug)]
pub struct EvmCodegen {
    functions: Vec<MirFunction>,
    receive: Option<MirFunction>,
    fallback: Option<MirFunction>,
}

impl EvmCodegen {
    /// Creates a new code generator with the given functions.
    pub fn new(functions: Vec<MirFunction>) -> Self {
        let mut ordinary = Vec::new();
        let mut receive = None;
        let mut fallback = None;

        for func in functions {
            match func.kind {
                FunctionKind::Receive => receive = Some(func),
                FunctionKind::Fallback => fallback = Some(func),
                _ => ordinary.push(func),
            }
        }

        Self { functions: ordinary, receive, fallback }
    }

    /// Generates the function dispatcher bytecode.
    pub fn generate_dispatcher(&self) -> Bytecode {
        let mut code = Bytecode::new();

        if self.functions.is_empty() && self.receive.is_none() && self.fallback.is_none() {
            code.emit(op::STOP);
            return code;
        }

        code.emit(op::CALLDATASIZE);
        code.emit(op::ISZERO);
        code.emit_jumpi_to("no_calldata");

        code.emit(op::PUSH0);
        code.emit(op::CALLDATALOAD);
        code.emit_push1(0xe0);
        code.emit(op::SHR);

        for (i, func) in self.functions.iter().enumerate() {
            if let Some(selector) = func.selector {
                let label = format!("func_{i}");

                code.emit(op::DUP1);
                code.emit_push4(selector);
                code.emit(op::EQ);
                code.emit_jumpi_to(&label);
            }
        }

        if let Some(ref fb) = self.fallback {
            if fb.state_mutability != StateMutability::Payable {
                code.emit(op::CALLVALUE);
                code.emit(op::ISZERO);
                code.emit_jumpi_to("fallback");
                code.emit(op::PUSH0);
                code.emit(op::PUSH0);
                code.emit(op::REVERT);
            }
            code.emit_jump_to("fallback");
        } else {
            code.emit(op::PUSH0);
            code.emit(op::PUSH0);
            code.emit(op::REVERT);
        }

        code.define_label("no_calldata");
        if let Some(ref recv) = self.receive {
            if recv.state_mutability != StateMutability::Payable {
                code.emit(op::CALLVALUE);
                code.emit(op::ISZERO);
                code.emit_jumpi_to("receive");
                code.emit(op::PUSH0);
                code.emit(op::PUSH0);
                code.emit(op::REVERT);
            }
            code.emit_jump_to("receive");
        } else if let Some(ref fb) = self.fallback {
            if fb.state_mutability != StateMutability::Payable {
                code.emit(op::CALLVALUE);
                code.emit(op::ISZERO);
                code.emit_jumpi_to("fallback");
                code.emit(op::PUSH0);
                code.emit(op::PUSH0);
                code.emit(op::REVERT);
            }
            code.emit_jump_to("fallback");
        } else {
            code.emit(op::PUSH0);
            code.emit(op::PUSH0);
            code.emit(op::REVERT);
        }

        for (i, func) in self.functions.iter().enumerate() {
            let label = format!("func_{i}");
            code.define_label(&label);

            if func.needs_value_check() {
                code.emit(op::CALLVALUE);
                code.emit(op::ISZERO);
                let ok_label = format!("func_{i}_payable_ok");
                code.emit_jumpi_to(&ok_label);
                code.emit(op::PUSH0);
                code.emit(op::PUSH0);
                code.emit(op::REVERT);
                code.define_label(&ok_label);
            }

            code.emit(op::STOP);
        }

        if self.receive.is_some() {
            code.define_label("receive");
            code.emit(op::STOP);
        }

        if self.fallback.is_some() {
            code.define_label("fallback");
            code.emit(op::STOP);
        }

        code.resolve_labels();
        code
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_function(
        name: &str,
        kind: FunctionKind,
        state_mutability: StateMutability,
    ) -> MirFunction {
        MirFunction {
            name: Some(name.to_string()),
            kind,
            state_mutability,
            selector: if kind.is_ordinary() {
                Some(crate::lower::compute_selector(name, &[]))
            } else {
                None
            },
        }
    }

    #[test]
    fn test_payable_function_no_check() {
        let funcs =
            vec![make_function("deposit", FunctionKind::Function, StateMutability::Payable)];
        let codegen = EvmCodegen::new(funcs);
        let bytecode = codegen.generate_dispatcher();

        let bytes = bytecode.as_bytes();
        assert!(!bytes.is_empty());

        let has_value_check_after_selector =
            bytes.windows(2).any(|w| w[0] == op::JUMPDEST && w[1] == op::STOP);
        assert!(has_value_check_after_selector);
    }

    #[test]
    fn test_non_payable_function_has_check() {
        let funcs =
            vec![make_function("nonPayable", FunctionKind::Function, StateMutability::NonPayable)];
        let codegen = EvmCodegen::new(funcs);
        let bytecode = codegen.generate_dispatcher();

        let bytes = bytecode.as_bytes();
        let has_callvalue = bytes.contains(&op::CALLVALUE);
        let has_iszero = bytes.contains(&op::ISZERO);
        let has_revert = bytes.contains(&op::REVERT);

        assert!(has_callvalue && has_iszero && has_revert);
    }

    #[test]
    fn test_view_function_has_check() {
        let funcs =
            vec![make_function("getBalance", FunctionKind::Function, StateMutability::View)];
        let codegen = EvmCodegen::new(funcs);
        let bytecode = codegen.generate_dispatcher();

        let bytes = bytecode.as_bytes();
        let has_callvalue = bytes.contains(&op::CALLVALUE);
        assert!(has_callvalue);
    }

    #[test]
    fn test_pure_function_has_check() {
        let funcs = vec![make_function("add", FunctionKind::Function, StateMutability::Pure)];
        let codegen = EvmCodegen::new(funcs);
        let bytecode = codegen.generate_dispatcher();

        let bytes = bytecode.as_bytes();
        let has_callvalue = bytes.contains(&op::CALLVALUE);
        assert!(has_callvalue);
    }

    #[test]
    fn test_receive_function() {
        let funcs = vec![make_function("", FunctionKind::Receive, StateMutability::Payable)];
        let codegen = EvmCodegen::new(funcs);
        let bytecode = codegen.generate_dispatcher();

        assert!(!bytecode.is_empty());
    }
}
