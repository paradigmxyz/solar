//! EVM bytecode generation from MIR.

use crate::mir::{Function, InstKind, Module, Terminator, Value, ValueId};
use alloy_primitives::U256;

/// EVM opcode constants.
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[allow(dead_code)]
enum Opcode {
    Stop = 0x00,
    Add = 0x01,
    Mul = 0x02,
    Sub = 0x03,
    Div = 0x04,
    SDiv = 0x05,
    Mod = 0x06,
    SMod = 0x07,
    AddMod = 0x08,
    MulMod = 0x09,
    Exp = 0x0a,
    SignExtend = 0x0b,

    Lt = 0x10,
    Gt = 0x11,
    SLt = 0x12,
    SGt = 0x13,
    Eq = 0x14,
    IsZero = 0x15,
    And = 0x16,
    Or = 0x17,
    Xor = 0x18,
    Not = 0x19,
    Byte = 0x1a,
    Shl = 0x1b,
    Shr = 0x1c,
    Sar = 0x1d,

    Keccak256 = 0x20,

    Address = 0x30,
    Balance = 0x31,
    Origin = 0x32,
    Caller = 0x33,
    CallValue = 0x34,
    CalldataLoad = 0x35,
    CalldataSize = 0x36,
    CalldataCopy = 0x37,
    CodeSize = 0x38,
    CodeCopy = 0x39,
    GasPrice = 0x3a,
    ExtCodeSize = 0x3b,
    ExtCodeCopy = 0x3c,
    ReturnDataSize = 0x3d,
    ReturnDataCopy = 0x3e,
    ExtCodeHash = 0x3f,

    BlockHash = 0x40,
    Coinbase = 0x41,
    Timestamp = 0x42,
    Number = 0x43,
    PrevRandao = 0x44,
    GasLimit = 0x45,
    ChainId = 0x46,
    SelfBalance = 0x47,
    BaseFee = 0x48,
    BlobHash = 0x49,
    BlobBaseFee = 0x4a,

    Pop = 0x50,
    MLoad = 0x51,
    MStore = 0x52,
    MStore8 = 0x53,
    SLoad = 0x54,
    SStore = 0x55,
    Jump = 0x56,
    JumpI = 0x57,
    Pc = 0x58,
    MSize = 0x59,
    Gas = 0x5a,
    JumpDest = 0x5b,
    TLoad = 0x5c,
    TStore = 0x5d,
    MCopy = 0x5e,

    Push0 = 0x5f,
    Push1 = 0x60,
    Push2 = 0x61,
    Push32 = 0x7f,

    Dup1 = 0x80,
    Swap1 = 0x90,

    Log0 = 0xa0,
    Log1 = 0xa1,
    Log2 = 0xa2,
    Log3 = 0xa3,
    Log4 = 0xa4,

    Create = 0xf0,
    Call = 0xf1,
    CallCode = 0xf2,
    Return = 0xf3,
    DelegateCall = 0xf4,
    Create2 = 0xf5,
    StaticCall = 0xfa,
    Revert = 0xfd,
    Invalid = 0xfe,
    SelfDestruct = 0xff,
}

/// EVM code generator.
pub struct EvmCodegen {
    /// The generated bytecode.
    bytecode: Vec<u8>,
    /// Block offsets for jump resolution.
    block_offsets: Vec<usize>,
}

impl EvmCodegen {
    /// Creates a new EVM code generator.
    #[must_use]
    pub fn new() -> Self {
        Self { bytecode: Vec::new(), block_offsets: Vec::new() }
    }

    /// Generates bytecode for a module.
    pub fn generate_module(&mut self, module: &Module) -> Vec<u8> {
        self.bytecode.clear();

        if !module.functions.is_empty() {
            self.generate_dispatcher(module);
        }

        for func in module.functions.iter() {
            self.generate_function(func);
        }

        std::mem::take(&mut self.bytecode)
    }

    /// Generates the function dispatcher.
    fn generate_dispatcher(&mut self, module: &Module) {
        self.emit(Opcode::Push0);
        self.emit(Opcode::CalldataLoad);

        self.emit(Opcode::Push1);
        self.bytecode.push(0xe0);
        self.emit(Opcode::Shr);

        for func in module.functions.iter() {
            if let Some(selector) = func.selector {
                self.emit(Opcode::Dup1);

                self.bytecode.push(Opcode::Push1 as u8 + 3);
                self.bytecode.extend_from_slice(&selector);

                self.emit(Opcode::Eq);
                self.emit(Opcode::Push2);
                self.bytecode.extend_from_slice(&[0x00, 0x00]);
                self.emit(Opcode::JumpI);
            }
        }

        self.emit(Opcode::Push0);
        self.emit(Opcode::Push0);
        self.emit(Opcode::Revert);
    }

    /// Generates bytecode for a function.
    fn generate_function(&mut self, func: &Function) {
        self.block_offsets.clear();
        self.block_offsets.resize(func.blocks.len(), 0);

        for (block_id, block) in func.blocks.iter_enumerated() {
            self.block_offsets[block_id.index()] = self.bytecode.len();
            self.emit(Opcode::JumpDest);

            for &inst_id in &block.instructions {
                let inst = &func.instructions[inst_id];
                self.generate_inst(func, &inst.kind);
            }

            if let Some(term) = &block.terminator {
                self.generate_terminator(func, term);
            }
        }
    }

    /// Generates bytecode for an instruction.
    fn generate_inst(&mut self, func: &Function, kind: &InstKind) {
        match kind {
            InstKind::Add(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::Add);
            }
            InstKind::Sub(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::Sub);
            }
            InstKind::Mul(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::Mul);
            }
            InstKind::Div(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::Div);
            }
            InstKind::SDiv(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::SDiv);
            }
            InstKind::Mod(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::Mod);
            }
            InstKind::SMod(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::SMod);
            }
            InstKind::Exp(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::Exp);
            }
            InstKind::And(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::And);
            }
            InstKind::Or(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::Or);
            }
            InstKind::Xor(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::Xor);
            }
            InstKind::Not(a) => {
                self.push_value(func, *a);
                self.emit(Opcode::Not);
            }
            InstKind::Shl(shift, val) => {
                self.push_value(func, *val);
                self.push_value(func, *shift);
                self.emit(Opcode::Shl);
            }
            InstKind::Shr(shift, val) => {
                self.push_value(func, *val);
                self.push_value(func, *shift);
                self.emit(Opcode::Shr);
            }
            InstKind::Sar(shift, val) => {
                self.push_value(func, *val);
                self.push_value(func, *shift);
                self.emit(Opcode::Sar);
            }
            InstKind::Lt(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::Lt);
            }
            InstKind::Gt(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::Gt);
            }
            InstKind::SLt(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::SLt);
            }
            InstKind::SGt(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::SGt);
            }
            InstKind::Eq(a, b) => {
                self.push_value(func, *b);
                self.push_value(func, *a);
                self.emit(Opcode::Eq);
            }
            InstKind::IsZero(a) => {
                self.push_value(func, *a);
                self.emit(Opcode::IsZero);
            }
            InstKind::MLoad(addr) => {
                self.push_value(func, *addr);
                self.emit(Opcode::MLoad);
            }
            InstKind::MStore(addr, val) => {
                self.push_value(func, *val);
                self.push_value(func, *addr);
                self.emit(Opcode::MStore);
            }
            InstKind::MStore8(addr, val) => {
                self.push_value(func, *val);
                self.push_value(func, *addr);
                self.emit(Opcode::MStore8);
            }
            InstKind::SLoad(slot) => {
                self.push_value(func, *slot);
                self.emit(Opcode::SLoad);
            }
            InstKind::SStore(slot, val) => {
                self.push_value(func, *val);
                self.push_value(func, *slot);
                self.emit(Opcode::SStore);
            }
            InstKind::TLoad(slot) => {
                self.push_value(func, *slot);
                self.emit(Opcode::TLoad);
            }
            InstKind::TStore(slot, val) => {
                self.push_value(func, *val);
                self.push_value(func, *slot);
                self.emit(Opcode::TStore);
            }
            InstKind::Keccak256(off, len) => {
                self.push_value(func, *len);
                self.push_value(func, *off);
                self.emit(Opcode::Keccak256);
            }
            InstKind::Caller => self.emit(Opcode::Caller),
            InstKind::CallValue => self.emit(Opcode::CallValue),
            InstKind::Address => self.emit(Opcode::Address),
            InstKind::Origin => self.emit(Opcode::Origin),
            InstKind::GasPrice => self.emit(Opcode::GasPrice),
            InstKind::Gas => self.emit(Opcode::Gas),
            InstKind::Timestamp => self.emit(Opcode::Timestamp),
            InstKind::BlockNumber => self.emit(Opcode::Number),
            InstKind::Coinbase => self.emit(Opcode::Coinbase),
            InstKind::ChainId => self.emit(Opcode::ChainId),
            InstKind::SelfBalance => self.emit(Opcode::SelfBalance),
            InstKind::BaseFee => self.emit(Opcode::BaseFee),
            InstKind::BlobBaseFee => self.emit(Opcode::BlobBaseFee),
            InstKind::GasLimit => self.emit(Opcode::GasLimit),
            InstKind::PrevRandao => self.emit(Opcode::PrevRandao),
            InstKind::CalldataSize => self.emit(Opcode::CalldataSize),
            InstKind::CodeSize => self.emit(Opcode::CodeSize),
            InstKind::ReturnDataSize => self.emit(Opcode::ReturnDataSize),
            InstKind::Balance(addr) => {
                self.push_value(func, *addr);
                self.emit(Opcode::Balance);
            }
            InstKind::CalldataLoad(off) => {
                self.push_value(func, *off);
                self.emit(Opcode::CalldataLoad);
            }
            InstKind::BlockHash(num) => {
                self.push_value(func, *num);
                self.emit(Opcode::BlockHash);
            }
            InstKind::BlobHash(idx) => {
                self.push_value(func, *idx);
                self.emit(Opcode::BlobHash);
            }
            InstKind::ExtCodeSize(addr) => {
                self.push_value(func, *addr);
                self.emit(Opcode::ExtCodeSize);
            }
            InstKind::ExtCodeHash(addr) => {
                self.push_value(func, *addr);
                self.emit(Opcode::ExtCodeHash);
            }
            _ => {}
        }
    }

    /// Generates bytecode for a terminator.
    fn generate_terminator(&mut self, func: &Function, term: &Terminator) {
        match term {
            Terminator::Jump(target) => {
                self.emit(Opcode::Push2);
                let offset = self.block_offsets.get(target.index()).copied().unwrap_or(0);
                self.bytecode.extend_from_slice(&(offset as u16).to_be_bytes());
                self.emit(Opcode::Jump);
            }
            Terminator::Branch { condition, then_block, else_block } => {
                self.push_value(func, *condition);
                self.emit(Opcode::Push2);
                let then_offset = self.block_offsets.get(then_block.index()).copied().unwrap_or(0);
                self.bytecode.extend_from_slice(&(then_offset as u16).to_be_bytes());
                self.emit(Opcode::JumpI);

                self.emit(Opcode::Push2);
                let else_offset = self.block_offsets.get(else_block.index()).copied().unwrap_or(0);
                self.bytecode.extend_from_slice(&(else_offset as u16).to_be_bytes());
                self.emit(Opcode::Jump);
            }
            Terminator::Return { values } => {
                if values.is_empty() {
                    self.emit(Opcode::Push0);
                    self.emit(Opcode::Push0);
                } else {
                    for &val in values.iter().rev() {
                        self.push_value(func, val);
                    }
                    self.emit(Opcode::Push0);
                    self.emit(Opcode::MStore);
                    self.emit(Opcode::Push1);
                    self.bytecode.push(0x20);
                    self.emit(Opcode::Push0);
                }
                self.emit(Opcode::Return);
            }
            Terminator::Revert { offset, size } => {
                self.push_value(func, *size);
                self.push_value(func, *offset);
                self.emit(Opcode::Revert);
            }
            Terminator::Stop => {
                self.emit(Opcode::Stop);
            }
            Terminator::SelfDestruct { recipient } => {
                self.push_value(func, *recipient);
                self.emit(Opcode::SelfDestruct);
            }
            Terminator::Switch { value, default, cases } => {
                for (case_val, target) in cases.iter() {
                    self.emit(Opcode::Dup1);
                    self.push_value(func, *case_val);
                    self.emit(Opcode::Eq);
                    self.emit(Opcode::Push2);
                    let offset = self.block_offsets.get(target.index()).copied().unwrap_or(0);
                    self.bytecode.extend_from_slice(&(offset as u16).to_be_bytes());
                    self.emit(Opcode::JumpI);
                }
                self.push_value(func, *value);
                self.emit(Opcode::Pop);
                self.emit(Opcode::Push2);
                let default_offset = self.block_offsets.get(default.index()).copied().unwrap_or(0);
                self.bytecode.extend_from_slice(&(default_offset as u16).to_be_bytes());
                self.emit(Opcode::Jump);
            }
            Terminator::Invalid => {
                self.emit(Opcode::Invalid);
            }
        }
    }

    /// Pushes a value onto the stack.
    fn push_value(&mut self, func: &Function, val_id: ValueId) {
        if let Value::Immediate(imm) = &func.values[val_id]
            && let Some(value) = imm.as_u256()
        {
            self.push_u256(value);
        }
    }

    /// Pushes a U256 value onto the stack.
    fn push_u256(&mut self, value: U256) {
        if value.is_zero() {
            self.emit(Opcode::Push0);
            return;
        }

        let bytes = value.to_be_bytes::<32>();
        let first_nonzero = bytes.iter().position(|&b| b != 0).unwrap_or(32);
        let len = 32 - first_nonzero;

        if len <= 32 {
            self.bytecode.push(Opcode::Push1 as u8 + (len as u8) - 1);
            self.bytecode.extend_from_slice(&bytes[first_nonzero..]);
        }
    }

    /// Emits an opcode.
    fn emit(&mut self, op: Opcode) {
        self.bytecode.push(op as u8);
    }
}

impl Default for EvmCodegen {
    fn default() -> Self {
        Self::new()
    }
}
